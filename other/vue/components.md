# 组件化

> vue官网关于组件化，记笔记

## 组件化

vue有两个核心思想，一个是数据双向绑定，一个是组件化。

### 组件化是什么

组件化就是整个页面是由一个个组件拼装而成的。一个组件通常实现某一功能或某一块样式，它所用到的资源（html、css、js），由它自身负责编写和维护。组件间可相互嵌套。

### vue里组件基础

```js
Vue.component('name', {
  el: '',
  data: {}
})
```

组件是可复用的vue实例，要复用需要定义名字，像自定义元素一样插入其他组件的html里

一个项目，只`new Vue`一个根实例，其他组件可以引入进来使用，把其他组件当成自定义元素插入

组件和`new Vue`接收的选项相同，仅有的例外是像 el 这样根实例特有的选项

组件可被重复复用，每插入一次，都会实例化一次，因此使用的时候会相互间独立

这里有一个注意的是，data这里要写成函数。如果写成对象，而对象是引用类型，它的值是一个指针，这样实例与实例间引用的是同一个对象，并不是我们想要的。

### 组件的组织

> 一个应用会以一个嵌套的组件树来组织起来

一个页面上，通常会有页面头部组件、内容区、侧边栏等组件，每个组件又包含图文卡片等组件

像之前使用 vue.component() 一样在vue里注册组件，这种注册是全局的，如何局部注册呢？

> 问：全局注册的组件，什么时候可以用？
> 答：可以在它注册后的，其他实例化的组件里

### 通过Prop向子组件传递数据

父子组件传值的一种方式

之前提到过嵌套组件，如果嵌入一个子组件，想让子组件显示一些信息，需要父组件传递给子组件一些信息

> 问：Prop是什么?
> 答：它是一个组件上的attribute，它的值是父组件传过来的。

父组件传过来的值，变成了这个子组件实例的属性 property。传递多个值，被放在子组件实例的props选项里，我们能够像访问data中数据一样访问props中数据。

> 问：子组件怎么把值传给父组件? (如果没有组件嵌套，按钮点击时，触发这个按钮上的点击监听事件，触发所绑定的事件。现在问题变成了组件相互间嵌套，那么子组件去点击时，如何去触发父组件的绑定事件？)
答：vue组件实例化后的实例，拥有一套事件系统，可以做这些事。 子组件触发某个事件(vue内建方法$emit， 第一个参数是事件名，第二个参数是子组件拋出的值)，父组件通过v-on写监听器监听事件，接收事件并触发回调。

### 在组件上使用v-model

我们可以在一个原生元素上使用v-model, 如input、textarea等

自定义事件也可以创建支持v-model的自定义输入组件

```html
<input v-model="searchText">

<input v-bind:value="searchText" v-on:input="searchText = $event.target.value">
```

用在组件上
```html
<xx v-model="yy"></xx>
```

### 动态组件

> 需求：有很多组件，想让这些组件根据用户的选择来决定具体去显示那个
> 解决：\<component>元素添加`is`
> 场景：选项卡，在不同组件间切换是非常常见，且很有用的

### 组件注册

> 需求：全局注册的组件，注册一次，全局都可以使用，即使只用一次，之后都不再使用，也会保留。特别不友好。有没有针对少数应用场景的，用一次就销毁，可只在一定范围内使用的注册？
> 解决：通过一个普通对象来定义组件。在components选项中定义你使用的组件

> 问：局部注册的在子组件中不可用？
> 答：是的，componentA和componentB不能相互用。如果想用，让一个出现在另一个的components里

> 问：组件怎么注册的，全局注册，局部注册?
> 答：全局vue.component()；局部，options里components: component

基础组件的自动化全局注册
一些组件是相对通用的：一些按钮、提示框、图文卡片、输入框
这些基础组件每个组件都会用，如果每个组件都引入一次，特别麻烦。
vue cli3+，可以使用require.context只全局注册这些基础组件，所有组件里可以直接用

全局组件的行为必须在`new Vue`实例化之前完成

### 单向数据流

数据是单向传递的
是由父组件向子组件传递的
而不能由子组件传给父组件
为什么要这样设计
为了防止子组件修改父组件状态，而父组件不好识别是那个子组件修改的
子组件里的prop会根据父组件的值改变而改变，这种设计，使子组件不能修改这些prop

有两种常见的试图修改prop的示例：
- 这个prop是父组件给子组件传递的一个初始值，而接下来子组件希望可以根据自己的实际交互而改变这个值。解决：子组件data里初始化一个值，将这个prop值作为data的值
- 父组件给子组件传递一个值，但子组件不能直接用，而需要进行一定的格式转换才能用。解决：使用computed

### 禁用Attribute继承

> 需求：不希望组件的根元素继承attribute
> 解决：在组件的选项里 inheritAttrs: false。
> 配合实例的$attrs
> $attrs包括了传递给子组件的特性名、特性值

有了inheritAttrs和$attrs就可以决定在那些元素上用特性和特性值。在撰写基础组件的时候经常用到.

好处：
允许你在使用基础组件时，像使用原生元素一样使用，而不必担心这些传进去的特性是否没有绑定到对应的元素上

### 自定义组件的v-model

一个组件上的v-model会默认利用名的value的prop，和名为input的事件; 但是单选框、复选框等类型的输入控件可能会将vlaue 用于其他目的。model选项可以避免这样的事情。

将原生事件绑定到组件，内部提供了v-on的修饰符 .native

自定义事件
需求：想在一个组件上的根元素上监听原生事件。

> 问题：一个类似input的元素重构后，在根元素上监听可能并不能达到预期效果
> 解决：vue提供了$listeners 特性, 它是一个对象.包含在这个组件上监听的所有监听器

可以配合v-on="$listners"将所有的事件监听器指向这个组件的特定元素

> 需求：有时候，我们可能需要对一个prop进行双向绑定
> 问题：真正的prop双向绑定会带来数据维护上的问题.因为子组件可以修改父组件的值，而子组件和父组件没有明确的来源
> 解决：推荐update:myPropName的模式触发事件取而代之。为方便，为这种模式提供缩写，.sync

v2.6 引入一个新的语法，v-slot指令，取代了slot和slot-scope，这两个已经废弃了但未移除

插槽内容
> 需求：提供内容分发的能力
> 解决：vue提供了一套内容分发的API
> 设计灵感：web component规范草案
> 将\<slot>作为内容分发的出口

> 记住：父级模板的所有内容都在父级作用域内解析，各自解析各自的模板

v-slot指令如何用
在向一个具名插槽提供内容的时候，可以在template元素上使用v-slot指令，并以v-slot的参数的形式提供其名称

注意v-slot只能添加在template上

> 需求：父组件里 template v-slot:header 等内容只能访问父组件的数据，如何让插槽访问子组件的数据呢
> 解决：可以将子级数据作为slot元素的一个attribute绑定上去

绑定在slot元素上的attribute被称为插槽prop.
在父级作用域内可以使用带值的v-slot来定义我们的插槽prop的名字

### 动态指令参数
template v-slot:[xxx]

具名插槽的缩写：v-slot可缩写成#

### 动态组件&异步组件

```html
<component :is='currentTabComponent'></component>
```

之前使用is来切换不同标签内容。根据值不同渲染不同的组件。每次切换时，vue都重新生成组件实例

> 需求：因为会频繁切换，如何保留组件的状态呢（避免重复渲染导致性能问题）
> 解决：使用<keep-alive>元素将这个动态组件包裹起来


### 异步组件

> 背景及需求：在大型应用里，将各个部分切分为一块块，只在需要的时候才从服务器加载这个模块。
> 解决：vue允许以一个工厂函数的模式定义你的组件，这个工厂函数会异步解析你的组件定义。

vue只有在这个组件需要被渲染时才会触发这个函数，而且把这个结果保存起来用于未来的渲染。

```js
vue.component('xx', function(resolve, reject) => {
  setTimeout(function(){
    resolve({
      template: 'xx'
    })
  }, time)
})
```

分析这个工厂函数，接收回调参数
这个函数会在从服务器得到组件定义时被调用。

setTimeout是用于演示使用
如何获取组件，取决于个人
推荐的做法：将异步组件和webpack的code-spliting功能一起配合使用

webpack里，require('./my-async-component', cb)

也可以在工厂函数中返回一个promise

局部注册时：
```js
components: {
  'my-async-component': () => import('./xx')
}
```

### 处理加载状态

> 需求：异步，需要处理加载状态
> 问题：怎么处理加载状态
> 解决：异步组件工厂函数也可以返回一个对象

```js
({
  component: import(''),
  loading: LoadingComponent,
  error: ErrorComponent,
  delay: time,
  timeout: time
})
```